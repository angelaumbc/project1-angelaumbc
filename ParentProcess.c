#include<stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/socket.h>
// Lets us know the adress and port of socket we want to connect to 
#include <netinet/in.h>
#define PORT 8080



// Creates a log for the individual LikesServer instances
// when they receive input back from the PrimaryLikesServer
// str input is the message they got back and i is the number
// the server
void proccessLikesLog(char str[], int i) {
    FILE* fp;
    // The output to the log includes a timestamp and the
    // amount of likes processed. These values are combined
    // to one string using concat.
    char tstr[10];
    sprintf(tstr, "%d", time(0));
    char output[100] = "";
    strcat(output, tstr);
    strcat(output, " - ");
    strcat(output, str);
    strcat(output, " Likes Processed");

    // The filename is generated using the i input and
    // a standard file name combined together
    char filename[20] = "/tmp/LikeServer";
    char* istr[4];
    sprintf(istr, "%d", i);
    strcat(filename, istr);

    // The output strnig generated is added to the end of
    // the fileName generated
    fp = fopen(filename, "a");
    fputs(output, fp);
    fprintf(fp, "\n");
    fclose(fp);
}

// This opens the ParentProcess log and adds the 
// string input to the end, either a timestamp showing
// the opening or closing of a child process (LikeServer).
void parentProcessStatus(char str[]) {
    FILE* fp;
    fp = fopen("/tmp/ParentProcessStatus", "a");
    fputs(str, fp);
    fprintf(fp, "\n");
    fclose(fp);

}


// We do not want the program to exit with any child processes running.
// This will check every child process and not cloe the program until this is complete.
// The pid_array is defined in the main function.
int CheckStatus(int pid_array[]) {
    int status;
    // all_closed = True as bools in C are just numbers
    int all_closed = 1;
    for (int i = 0; i < 10; i++) {
        // Iterates through the 10 child processes craeted by the fork (the LikeServers)
        // and checks their individual pids. If the pid status indicates it is still working
        // the flag returned by this program indicates not all are closed. If the array says
        // something is working but it isn't, we update the value in the pid_array to -1 as
        // this mans the child process has closed and we do not reopen processes again.
        if (pid_array[i] != -1) {
            pid_t return_pid = waitpid(pid_array[i], &status, WNOHANG);
            if (return_pid == pid_array[i]) {
                char tstr[10];
                // Turning the timestamp into a string so we can indicate to the 
                // client log that the process has officially closed
                sprintf(tstr, "%d", time(0)); 

                char destination[100] = "";
                strcat(destination, tstr);
                strcat(destination, " - Closed likeServer");
                char istr[4];
                sprintf(istr, "%d", i);
                strcat(destination, istr);
                parentProcessStatus(destination);
                // Process is finished running so set back to -1
                pid_array[i] = -1;
            }
            else if (return_pid == 0) {
                // all closed = False as bools in C are just numbers
                all_closed = 0;
            }
        }
    }
    return all_closed;
}


int main()
{
    // This starts off as all -1 values indicating there are no child processes running
    // -1 = Not Running while PID (any positive values) = running
    int process_status[10] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
    for (int i = 0; i < 10; i++)
    {
        // This is what keeps the server alive for 5 minutes, as we will be comparing this value
        // against the total time spent. 300 = 60 * 5 = 5 minutes
        int childLiveTime = 300;
        int pid = fork();
        // Fork equals zero when it returns the newly created child process
        // Child processes in this case equal the LikeServers generated by the
        // ParentProcess
        if (pid == 0)
        {
            int totalSeconds = 0;
            // Random seed generated based on tmiestamp so each child generates
            // different like values.
            srand(time(0));
            // Value of likes based on random number generated below. Cumulative until
            // call from PrimaryServer resets the counter.
            int r = 0;
            while (totalSeconds < childLiveTime) {
                // Generates Socket to Connect to Server
                int sock = 0, valread, client_fd;
                struct sockaddr_in serv_addr;
                char buffer[1024] = { 0 };
                if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
                    printf("\n Unable to create Socket \n");
                    return -1;
                }

                serv_addr.sin_family = AF_INET;
                serv_addr.sin_port = htons(PORT);

               
                if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)
                    <= 0) {
                    printf(
                        "\nAddress is not supported \n");
                    return -1;
                }
                if ((client_fd
                    = connect(sock, (struct sockaddr*)&serv_addr,
                        sizeof(serv_addr)))
                    < 0) {
                    printf("\nUnable to Connect \n");
                    return -1;
                }

                // Generates message to PrimaryLikesServer based on
                // random number of likes generated concated to 
                // the likeserver id.
                r = r + (rand() % 43);

                char data_to_send[20] = "likeServer";
                char rstr[4];
                char istr[4];
                sprintf(istr, "%d", i);
                strcat(data_to_send, istr);
                strcat(data_to_send, " ");
                sprintf(rstr, "%d", r);
                strcat(data_to_send, rstr);

                // Sending the above message to the server
                send(sock, data_to_send, strlen(data_to_send), 0);
                printf("Sending: %s\n", data_to_send);

                // This above is supposed to run on a randomized 1-5 second
                // interval, which is defined here and used in a sleep function
                // below. This time is also added to total time to verify it runs
                // 5 minutes.
                int sleepr = (rand() % 5) + 1;
                // Caps at 5 minutes, adjusts to make sure ceiling isn't surpassed
                if (totalSeconds + sleepr >= childLiveTime) {
                    sleepr = childLiveTime - totalSeconds;
                }
                totalSeconds = totalSeconds + sleepr;

                // Reads the value back from the server. If the value indicates that
                // this socket was processed, log it and reset the counter back to zero.
                valread = read(sock, buffer, 1024);
                if (strcmp(buffer, data_to_send) == 0) {
                    r = 0;
                    proccessLikesLog(buffer, i);
                }
                sleep(sleepr);
                // Closing the connected socket for next process
                close(client_fd);
            }
            exit(0);
        }
        // For the Parent Process, we are nidicating to our status program that
        // the PID has been created and then outputting this to our log file.
        process_status[i] = pid;
        CheckStatus(process_status);
        char tstr[10];
        sprintf(tstr, "%d", time(0));

        char destination[100] = "";
        strcat(destination, tstr);
        strcat(destination, " - Started likeServer");
        char istr[4];
        sprintf(istr, "%d", i);
        strcat(destination, istr);
        parentProcessStatus(destination);
        // Servers are initially created every second.
        sleep(1);

    }

    // Does not close the program until all processes have finished.
    while (CheckStatus(process_status) != 1) {
        sleep(1);
    }
    printf("Done\n");
}


